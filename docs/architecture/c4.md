# C4 – Architektura HSS

## C4 L2 – Kontenery (docelowo, MVP startuje od tego samego układu)

Użytkownik (kandydat) → Reverse Proxy (Nginx/Traefik) → Frontend Web (Next.js) → Backend API (NestJS) → PostgreSQL  
Członek kapituły → Reverse Proxy (Nginx/Traefik) → Frontend Web (Next.js) → Backend API (NestJS) → PostgreSQL  
Backend API → S3 Storage (MinIO) (załączniki, PDF)  
Backend API → Redis/BullMQ → Worker (PDF/OCR/Notifications)  
Frontend/Backend → Keycloak (OIDC) (logowanie, tokeny)  
Observability: logi strukturalne + Sentry + opcjonalnie OpenTelemetry

Uwagi:

- W dev możemy uruchamiać bez reverse proxy (porty localhost), ale utrzymujemy tryb `dev-proxy/staging`, żeby testować redirecty OIDC, cookies i routing jak w prod.
- W staging/prod publicznie wystawiony jest tylko reverse proxy (80/443).

## C4 L3 – Komponenty (Backend API – modularny monolit)

- IdentityAccessModule
  - OIDC/JWT validation (issuer/audience/jwks)
  - RBAC policies, guards
- TrialsModule
  - TrialService (workflow statusów, reguły)
  - TrialQuery (listy, filtry)
  - CommentsService
  - RequirementsService (instancje wymagań, statusy)
  - Evidence/Witness management
- MeetingsModule
  - MeetingsService (CRUD terminów)
  - RegistrationsService (zapisy, limit miejsc)
- FilesModule
  - Presigned upload/download (S3)
  - StoredFile metadata
- DocumentsModule (później)
  - Rejestr dokumentów, generowanie PDF w workerze
- AuditComplianceModule
  - AuditLogService
  - Historia statusów (TrialStatusHistory)
- Shared
  - PrismaService
  - Logging/CorrelationId interceptors
  - Domain Events (in-proc → później kolejka)

## Zasada

Preferujemy modularny monolit z jasnymi granicami modułów; worker jako osobny proces dla zadań asynchronicznych.
